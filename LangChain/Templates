The current LangGraph template defines a StateGraph using LangChain annotations and states. This setup is a framework or "template" for an AI character or "agent" that interacts with a user by receiving user input, processing context, and generating an AI-driven response. Here's a breakdown:

GraphState and Annotations:

GraphState defines the structure of the conversation, with annotations to manage the conversation history (messages) and the specific agent (agentData).
The messages annotation collects AI-generated and user-provided messages, forming a dialogue history that helps make interactions feel more coherent.
agentData represents metadata specific to each agent, allowing each agent to have a unique identity or personality.
retrieveAgentContext:

This function aims to retrieve contextual information specific to each agent, enriching the AI's response by including relevant information from past interactions or predefined context.
processUserInput:

This main function combines the userInput with the retrieved context, creates an initial state (initialState), and then passes this to LangGraph.
The LangGraph workflow, created in app.invoke, processes this input and generates the next response in the conversation.
Template #1: Storyteller AI
A Storyteller AI template allows the agent to build a narrative based on user input, engaging in imaginative storytelling.

javascript
Copy code
const StorytellerGraphState = Annotation.Root({
  messages: Annotation<BaseMessage[]>({ reducer: (x, y) => x.concat(y) }),
  theme: Annotation<string>(), // Theme for the story (e.g., fantasy, mystery)
  protagonist: Annotation<string>(), // Main character name or type
});

const storytellerNodeFn = async (_state) => {
  const themeContext = `In a world of ${_state.theme}, a ${_state.protagonist} emerges.`;
  const userStoryPrompt = `${themeContext} The journey begins: ${_state.userInput}`;
  return { messages: [new HumanMessage(userStoryPrompt)] };
};

const storytellerWorkflow = new StateGraph(StorytellerGraphState)
  .addNode('start', storytellerNodeFn)
  .addEdge(START, 'start')
  .addEdge('start', END);

const storytellerApp = storytellerWorkflow.compile({});
Template #2: Tutorial Guide AI
A Tutorial Guide AI template is ideal for agents that guide players or users through tasks, providing hints or directions as needed.

javascript
Copy code
const TutorialGraphState = Annotation.Root({
  messages: Annotation<BaseMessage[]>({ reducer: (x, y) => x.concat(y) }),
  currentTask: Annotation<string>(), // The task or level the user is currently on
  hintLevel: Annotation<number>(), // Level of hints to provide (0 = none, 1 = basic, 2 = detailed)
});

const tutorialNodeFn = async (_state) => {
  const hint = _state.hintLevel > 0 ? `Here's a hint for ${_state.currentTask}: Try looking around for clues.` : '';
  const userTutorialPrompt = `You are on the task: ${_state.currentTask}. ${hint} ${_state.userInput}`;
  return { messages: [new HumanMessage(userTutorialPrompt)] };
};

const tutorialWorkflow = new StateGraph(TutorialGraphState)
  .addNode('start', tutorialNodeFn)
  .addEdge(START, 'start')
  .addEdge('start', END);

const tutorialApp = tutorialWorkflow.compile({});
Template #3: Shopping Assistant AI
This template suits an agent designed to help users find items or offer suggestions in an in-game store or shopping simulation.

javascript
Copy code
const ShoppingGraphState = Annotation.Root({
  messages: Annotation<BaseMessage[]>({ reducer: (x, y) => x.concat(y) }),
  userPreferences: Annotation<string>(), // Items or types user prefers
  budget: Annotation<number>(), // Budget limit
});

const shoppingNodeFn = async (_state) => {
  const preferenceContext = `You seem interested in ${_state.userPreferences}, with a budget of $${_state.budget}.`;
  const userShoppingPrompt = `${preferenceContext} What would you like to explore? ${_state.userInput}`;
  return { messages: [new HumanMessage(userShoppingPrompt)] };
};

const shoppingWorkflow = new StateGraph(ShoppingGraphState)
  .addNode('start', shoppingNodeFn)
  .addEdge(START, 'start')
  .addEdge('start', END);

const shoppingApp = shoppingWorkflow.compile({});
Template #4: Puzzle Solver AI
A Puzzle Solver AI template could help guide users through puzzles, offering clues based on previous moves or mistakes.

javascript
Copy code
const PuzzleGraphState = Annotation.Root({
  messages: Annotation<BaseMessage[]>({ reducer: (x, y) => x.concat(y) }),
  puzzleType: Annotation<string>(), // Type of puzzle (e.g., logic, math)
  attempts: Annotation<number>(), // Number of attempts made
});

const puzzleNodeFn = async (_state) => {
  const hint = _state.attempts > 2 ? `Hint: Remember the basic rules of ${_state.puzzleType} puzzles.` : '';
  const userPuzzlePrompt = `You are working on a ${_state.puzzleType} puzzle. ${hint} ${_state.userInput}`;
  return { messages: [new HumanMessage(userPuzzlePrompt)] };
};

const puzzleWorkflow = new StateGraph(PuzzleGraphState)
  .addNode('start', puzzleNodeFn)
  .addEdge(START, 'start')
  .addEdge('start', END);

const puzzleApp = puzzleWorkflow.compile({});
Template #5: Combat Companion AI
A Combat Companion AI template serves as an assistant during battles, giving users strategic advice based on current combat conditions.

javascript
Copy code
const CombatGraphState = Annotation.Root({
  messages: Annotation<BaseMessage[]>({ reducer: (x, y) => x.concat(y) }),
  currentHealth: Annotation<number>(), // Player's health level
  enemyType: Annotation<string>(), // Type of enemy faced
  enemyHealth: Annotation<number>(), // Enemy's health level
});

const combatNodeFn = async (_state) => {
  const advice = _state.currentHealth < 20 ? "Watch out, your health is low!" : `Enemy ${_state.enemyType} at ${_state.enemyHealth}% health.`;
  const userCombatPrompt = `${advice} ${_state.userInput}`;
  return { messages: [new HumanMessage(userCombatPrompt)] };
};

const combatWorkflow = new StateGraph(CombatGraphState)
  .addNode('start', combatNodeFn)
  .addEdge(START, 'start')
  .addEdge('start', END);

const combatApp = combatWorkflow.compile({});
Summary of Templates
Storyteller AI: Engages users in a creative narrative, expanding on user input with storytelling context.
Tutorial Guide AI: Guides users through tasks or levels, providing hints based on the current task and difficulty level.
Shopping Assistant AI: Assists users in navigating an in-game store, offering suggestions based on preferences and budget.
Puzzle Solver AI: Supports users with hints and encouragement while solving puzzles, based on their progress and past mistakes.
Combat Companion AI: Provides strategic advice during battles, taking into account health and enemy type for dynamic gameplay.
These templates can be customized and expanded further to create diverse and immersive AI interactions within Unity-based games or simulations.
